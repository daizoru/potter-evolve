// Generated by CoffeeScript 1.3.3
(function() {
  var Potter, center, deck, error, fitness, getNeighbors, getNeighborsFull, inspect, kernel, log, mat, model, model2, nMatrix, name, randNorm, read, step, write, x, y, z, _i, _j, _k, _l, _m, _n, _o, _ref;

  _ref = require('util'), log = _ref.log, error = _ref.error, inspect = _ref.inspect;

  Potter = require('potter');

  deck = require('deck');

  fitness = require('./fitness');

  name = "automata1";

  model = new Potter({
    size: [1e3, 1e3, 1e3]
  });

  center = [200, 200, 200];

  /*
  
    TODO
    
    - data stream
    - physical simulation step
    - WebGL viewer
  */


  nMatrix = [[0, +1, +1], [+1, +1, +1], [-1, 0, +1], [0, 0, +1], [+1, 0, +1], [-1, 0, +1], [0, -1, +1], [+1, -1, +1], [-1, +1, 0], [0, +1, 0], [+1, +1, 0], [-1, 0, 0], [+1, 0, 0], [-1, 0, 0], [0, -1, 0], [+1, -1, 0], [-1, +1, -1], [0, +1, -1], [+1, +1, -1], [-1, 0, -1], [0, 0, -1], [+1, 0, -1], [-1, -1, -1], [0, -1, -1], [+1, -1, -1]];

  randNorm = function(t, r) {
    if (t == null) {
      t = 0.0;
    }
    if (r == null) {
      r = 1e3;
    }
    return Number(deck.pick({
      '-1': r - r * t,
      '0': r,
      '1': r + r * t
    }));
  };

  getNeighborsFull = function(p) {
    var n, neighbors, pos, x, y, z, _i, _len;
    x = p[0], y = p[1], z = p[2];
    neighbors = {};
    for (_i = 0, _len = nMatrix.length; _i < _len; _i++) {
      n = nMatrix[_i];
      pos = [x + n[0], y + n[1], z + n[2]];
      neighbors.push([pos, model.get(pos)]);
    }
    return neighbors;
  };

  getNeighbors = function(p) {
    var n, neighbors, x, y, z, _i, _len;
    x = p[0], y = p[1], z = p[2];
    neighbors = [];
    for (_i = 0, _len = nMatrix.length; _i < _len; _i++) {
      n = nMatrix[_i];
      neighbors.push(model.get([x + n[0], y + n[1], z + n[2]]));
    }
    return neighbors;
  };

  read = function(p) {
    return model.get(p).values;
  };

  write = function(p, values) {
    var material;
    if (values == null) {
      values = [];
    }
    material = model.material({
      values: values
    });
    model.use(material);
    log("writing mat: " + material.values + " at " + p);
    return model.dot(p, true);
  };

  kernel = function(position, state) {
    var add, dec, effect, equal, fget, fidx, filter, fsafe, fset, getvalue, inc, n, neighborvalue, point, prandunit, rand, relay, remove, returnNow, rule, rules, safe, saveCPUWhenPositive, setvalue, skipRule, sub, weak, x, y, z, _i, _len;
    n = getNeighbors(position);
    x = position[0], y = position[1], z = position[2];
    rules = [];
    safe = function(v) {
      if (v < -1.0) {
        v = -1.0;
      } else if (v > 1.0) {
        v = 1.0;
      }
      return v;
    };
    fsafe = function(func) {
      return safe(func);
    };
    point = function(x, y, z) {
      return model.get([x, y, z]);
    };
    fidx = function(array, i) {
      var index, len;
      len = array.length;
      if (len === 0) {
        return -1;
      }
      i = (i + 1.0) * 0.5;
      return index = Math.round(i * (len - 1));
    };
    fget = function(array, i) {
      var index, len;
      len = array.length;
      if (len === 0) {
        return 0.0;
      }
      i = (i + 1.0) * 0.5;
      log("A: " + i);
      index = Math.round(i * (len - 1));
      log("B: " + index);
      return array[index];
    };
    fset = function(array, i, v) {
      var index, len;
      len = array.length;
      if (len === 0) {
        return v;
      }
      i = (i + 1.0) * 0.5;
      index = Math.round(i * (len - 1));
      array[index] = v;
      return v;
    };
    returnNow = false;
    saveCPUWhenPositive = function(p) {
      p = safe(p);
      if (p > 0.0) {
        returnNow = true;
      }
      return p;
    };
    skipRule = false;
    rand = function() {
      return 1.0 - Math.random() * 2.0;
    };
    setvalue = function(i, v) {
      i = safe(i);
      v = safe(v);
      return fset(state.values, i, v);
    };
    getvalue = function(i) {
      i = safe(i);
      log("safe i: " + i);
      return fget(state.values, i);
    };
    equal = function(a, b, e) {
      a = safe(a);
      b = safe(b);
      e = Math.abs(safe(e));
      if (((b - e) <= a && a <= (b + e))) {
        return 1.0;
      } else {
        return 0.0;
      }
    };
    equal = function(a, b) {
      if (safe(a) === safe(b)) {
        return 1.0;
      } else {
        return 0.0;
      }
    };
    dec = function(v) {
      if (!(v != null)) {
        return 0;
      } else {
        return safe(v) - 0.01;
      }
    };
    inc = function(v) {
      if (!(v != null)) {
        return 0;
      } else {
        return safe(v) + 0.01;
      }
    };
    sub = function(a, b) {
      return safe(a) - safe(b);
    };
    add = function(a, b) {
      return safe(a) + safe(b);
    };
    filter = function(s, f) {
      if (f == null) {
        f = 1.0;
      }
      return safe(s) * safe(f);
    };
    weak = function(s) {
      return safe(s) * rand();
    };
    prandunit = function(p) {
      if (safe(p) > 0.0) {
        return Math.random();
      } else {
        return 1.0 - Math.random();
      }
    };
    relay = function(p, v) {
      p = safe(p);
      v = safe(v);
      if (rand() > 0.0) {
        return v;
      } else {
        return 0.0;
      }
    };
    remove = function(i) {
      i = safe(i);
      rules.splice(fidx(i, rules), 1);
      return i;
    };
    neighborvalue = function(n, i) {
      var values;
      n = safe(n);
      i = safe(i);
      values = fget(neighbors, n);
      return fget(values, i);
    };
    rules.push(function() {});
    rules.push(function() {
      return log("state value0: " + state.values[0] + " value: " + (getvalue(0.8)));
    });
    for (_i = 0, _len = rules.length; _i < _len; _i++) {
      rule = rules[_i];
      returnNow = false;
      skipRule = false;
      effect = rule();
      if (returnNow) {
        log("return now");
        return;
      }
      if (skipRule) {
        continue;
      }
    }
    return state;
  };

  log("step 1: contamination");

  for (x = _i = 0; _i < 2; x = ++_i) {
    for (y = _j = 0; _j < 2; y = ++_j) {
      for (z = _k = 0; _k < 2; z = ++_k) {
        write([x, y, z], [0, 0, 0, 0, 0]);
      }
    }
  }

  log("writing seed");

  write([1, 1, 1], [1, 0, 0, 0, 0]);

  log(" - " + model.count + " cells\n");

  log("step 2: proliferation");

  for (step = _l = 1; _l <= 1; step = ++_l) {
    log("   - timestep " + step + " (" + model.count + " cells)");
    model.map(kernel);
  }

  log(" - " + model.count + " cells\n");

  model2 = new Potter({
    size: [1e3, 1e3, 1e3]
  });

  for (x = _m = 0; _m < 5; x = ++_m) {
    for (y = _n = 0; _n < 5; y = ++_n) {
      for (z = _o = 0; _o < 5; z = ++_o) {
        mat = model2.material({
          values: [Math.round(Math.random()), 0, 0, 0, 0]
        });
        model2.use(mat);
        if (Math.random() > 0.5 && x > 2) {
          model2.dot([x, y, z], true);
        }
      }
    }
  }

  log("comparing models");

  fitness.compare(model, model2);

  log("step 3: remove dead cells");

  model.filter(function(p, state) {
    return state.values[0];
  });

  log(" - " + model.count + " cells\n");

}).call(this);
