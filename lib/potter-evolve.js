// Generated by CoffeeScript 1.3.3
(function() {
  var Potter, async, deck, error, fitness, generate, inspect, kernel, log, wait, write, _ref, _ref1, _ref2;

  _ref = require('util'), log = _ref.log, error = _ref.error, inspect = _ref.inspect;

  _ref1 = require('ragtime'), async = _ref1.async, wait = _ref1.wait;

  Potter = require('potter');

  deck = require('deck');

  fitness = require('./fitness');

  _ref2 = require('./automata'), write = _ref2.write, kernel = _ref2.kernel;

  generate = function(timesteps, cb) {
    if (timesteps == null) {
      timesteps = 1;
    }
    return async(function() {
      var center, mat, model, model2, name, step, x, y, z, _i, _j, _k, _l, _m, _n, _o;
      name = "automata1";
      model = new Potter({
        size: [1e3, 1e3, 1e3]
      });
      center = [200, 200, 200];
      log("step 1: contamination");
      for (x = _i = 0; _i < 2; x = ++_i) {
        for (y = _j = 0; _j < 2; y = ++_j) {
          for (z = _k = 0; _k < 2; z = ++_k) {
            write(model, [x, y, z], [0, 0, 0, 0, 0]);
          }
        }
      }
      log("writing seed");
      write(model, [1, 1, 1], [1, 0, 0, 0, 0]);
      log(" - " + model.count + " cells\n");
      log("step 2: proliferation");
      for (step = _l = 1; 1 <= timesteps ? _l <= timesteps : _l >= timesteps; step = 1 <= timesteps ? ++_l : --_l) {
        log("   - timestep " + step + " (" + model.count + " cells)");
        model.map(function(position, state) {
          return kernel(model, position, state);
        });
      }
      log(" - " + model.count + " cells\n");
      model2 = new Potter({
        size: [1e3, 1e3, 1e3]
      });
      for (x = _m = 0; _m < 5; x = ++_m) {
        for (y = _n = 0; _n < 5; y = ++_n) {
          for (z = _o = 0; _o < 5; z = ++_o) {
            mat = model2.material({
              values: [Math.round(Math.random()), 0, 0, 0, 0]
            });
            model2.use(mat);
            if (Math.random() > 0.5 && x > 2) {
              model2.dot([x, y, z], true);
            }
          }
        }
      }
      log("comparing models");
      fitness.compare(model, model2);
      log("step 3: remove dead cells");
      model.filter(function(p, state) {
        return state.values[0];
      });
      return async(function() {
        return cb(model);
      });
    });
  };

  exports.cli = function() {
    var timesteps, _ref3;
    timesteps = Number((_ref3 = process.argv[2]) != null ? _ref3 : 1);
    return generate(timesteps, function(model) {
      return log(" - " + model.count + " cells\n");
    });
  };

  exports.generateModel = generate;

}).call(this);
