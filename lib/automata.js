// Generated by CoffeeScript 1.3.3
(function() {
  var NearestCells, Potter, deck, error, getNeighbors, getNeighborsFull, inspect, kernel, log, randNorm, read, write, _ref;

  _ref = require('util'), log = _ref.log, error = _ref.error, inspect = _ref.inspect;

  Potter = require('potter');

  deck = require('deck');

  NearestCells = require('./neighbourhood');

  randNorm = function(t, r) {
    if (t == null) {
      t = 0.0;
    }
    if (r == null) {
      r = 1e3;
    }
    return Number(deck.pick({
      '-1': r - r * t,
      '0': r,
      '1': r + r * t
    }));
  };

  exports.getNeighborsFull = getNeighborsFull = function(model, p) {
    var n, neighbors, pos, x, y, z, _i, _len;
    x = p[0], y = p[1], z = p[2];
    neighbors = {};
    for (_i = 0, _len = NearestCells.length; _i < _len; _i++) {
      n = NearestCells[_i];
      pos = [x + n[0], y + n[1], z + n[2]];
      neighbors.push([pos, model.get(pos)]);
    }
    return neighbors;
  };

  exports.getNeighbors = getNeighbors = function(model, p) {
    var n, neighbors, x, y, z, _i, _len;
    x = p[0], y = p[1], z = p[2];
    neighbors = [];
    for (_i = 0, _len = NearestCells.length; _i < _len; _i++) {
      n = NearestCells[_i];
      neighbors.push(model.get([x + n[0], y + n[1], z + n[2]]));
    }
    return neighbors;
  };

  exports.read = read = function(model, p) {
    return model.get(p).values;
  };

  exports.write = write = function(model, p, values) {
    var material;
    if (values == null) {
      values = [];
    }
    material = model.material({
      values: values
    });
    model.use(material);
    log("writing mat: " + material.values + " at " + p);
    return model.dot(p, true);
  };

  exports.kernel = kernel = function(model, position, state) {
    var add, dec, effect, equal, fget, fidx, filter, fsafe, fset, getvalue, inc, n, neighborvalue, point, prandunit, rand, relay, remove, returnNow, rule, rules, safe, saveCPUWhenPositive, setvalue, skipRule, sub, weak, x, y, z, _i, _len;
    n = getNeighbors(model, position);
    x = position[0], y = position[1], z = position[2];
    rules = [];
    safe = function(v) {
      if (v < -1.0) {
        v = -1.0;
      } else if (v > 1.0) {
        v = 1.0;
      }
      return v;
    };
    fsafe = function(func) {
      return safe(func);
    };
    point = function(x, y, z) {
      return model.get([x, y, z]);
    };
    fidx = function(array, i) {
      var index, len;
      len = array.length;
      if (len === 0) {
        return -1;
      }
      i = (i + 1.0) * 0.5;
      return index = Math.round(i * (len - 1));
    };
    fget = function(array, i) {
      var index, len;
      len = array.length;
      if (len === 0) {
        return 0.0;
      }
      i = (i + 1.0) * 0.5;
      log("A: " + i);
      index = Math.round(i * (len - 1));
      log("B: " + index);
      return array[index];
    };
    fset = function(array, i, v) {
      var index, len;
      len = array.length;
      if (len === 0) {
        return v;
      }
      i = (i + 1.0) * 0.5;
      index = Math.round(i * (len - 1));
      array[index] = v;
      return v;
    };
    returnNow = false;
    saveCPUWhenPositive = function(p) {
      p = safe(p);
      if (p > 0.0) {
        returnNow = true;
      }
      return p;
    };
    skipRule = false;
    rand = function() {
      return 1.0 - Math.random() * 2.0;
    };
    setvalue = function(i, v) {
      i = safe(i);
      v = safe(v);
      return fset(state.values, i, v);
    };
    getvalue = function(i) {
      i = safe(i);
      log("safe i: " + i);
      return fget(state.values, i);
    };
    equal = function(a, b, e) {
      a = safe(a);
      b = safe(b);
      e = Math.abs(safe(e));
      if (((b - e) <= a && a <= (b + e))) {
        return 1.0;
      } else {
        return 0.0;
      }
    };
    equal = function(a, b) {
      if (safe(a) === safe(b)) {
        return 1.0;
      } else {
        return 0.0;
      }
    };
    dec = function(v) {
      if (!(v != null)) {
        return 0;
      } else {
        return safe(v) - 0.01;
      }
    };
    inc = function(v) {
      if (!(v != null)) {
        return 0;
      } else {
        return safe(v) + 0.01;
      }
    };
    sub = function(a, b) {
      return safe(a) - safe(b);
    };
    add = function(a, b) {
      return safe(a) + safe(b);
    };
    filter = function(s, f) {
      if (f == null) {
        f = 1.0;
      }
      return safe(s) * safe(f);
    };
    weak = function(s) {
      return safe(s) * rand();
    };
    prandunit = function(p) {
      if (safe(p) > 0.0) {
        return Math.random();
      } else {
        return 1.0 - Math.random();
      }
    };
    relay = function(p, v) {
      p = safe(p);
      v = safe(v);
      if (rand() > 0.0) {
        return v;
      } else {
        return 0.0;
      }
    };
    remove = function(i) {
      i = safe(i);
      rules.splice(fidx(i, rules), 1);
      return i;
    };
    neighborvalue = function(n, i) {
      var values;
      n = safe(n);
      i = safe(i);
      values = fget(neighbors, n);
      return fget(values, i);
    };
    rules.push(function() {});
    rules.push(function() {
      return log("state value0: " + state.values[0] + " value: " + (getvalue(0.8)));
    });
    for (_i = 0, _len = rules.length; _i < _len; _i++) {
      rule = rules[_i];
      returnNow = false;
      skipRule = false;
      effect = rule();
      if (returnNow) {
        log("return now");
        return;
      }
      if (skipRule) {
        continue;
      }
    }
    return state;
  };

}).call(this);
